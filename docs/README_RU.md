## Оглавление
1. [Описание](#desc)
2. [Методика работы](#work)

    2.1 [Application](#application)
    
    2.2 [Service](#service)

    2.3 [Этапы работы приложения](#state)

    2.4 [Безопасное завершение приложения](#graceful)
---

<a name="desc"></a>
### 1. Описание

Пакет решает задачу по организации запуска, управления и остановки приложения.
В рамках пакета используются следующие термины:

1. **Программа** - совокупный исходный код, который может быть преобразован в исполняемый файл.
2. **Приложение** - главная структурная часть программы, осуществляющая управление внутренними процессами.
3. **Сервис** - часть программы, которая использует внешние и внутренние ресурсы для реализации правил, 
принципов, зависимостей поведения предметной области.
4. **Ресурс** - минимальная структурная единица. Самостоятельная часть программы не требующая для своего 
запуска зависимостей.

Если исходить из обобщенных понятий чистой архитектуры, то **сервис** можно сопоставить - слою API, благодаря которому 
осуществляется обработка внешних запросов, а **ресурс** - слою репозиторному, который в свою очередь выполняет внешние 
или внутренние запросы (например, базе данных). 

Остановка **сервиса** должна вызвать прекращение приема внешних запросов, однако все активные запросы должны быть 
завершены в соответствии с логикой **сервиса**. После завершения работы всех **сервисов** отключение всех **ресурсов** 
может происходить асинхронно. 

<a name="work"></a>
### 2. Методика работы

<a name="application"></a>
#### 2.1 Application

Главной сущность пакета является структура [Application](https://github.com/Auvitly/application/blob/e13a0dbd066e946908eaabb410cc1b00a9e57931/application.go#L15).
Пример создания:

````go
package main

import (
	"github.com/Auvitly/application"
	"time"
)

...

func main (

// Определяем конфигурацию приложения
var config = &application.Config{
	// InitialisationTimeout - ограничение по времени для инициализации.
	// При нулевом значении таймаут не используется
	InitialisationTimeout: time.Second,
	// InitialisationTimeout - ограничение по времени для завершения приложения.
	// При нулевом значении таймаут не используется
	TerminationTimeout: time.Second,
	// EnableDebugStack - флаг определяющий включен ли подробный вывод ошибки 
	// в случае паники сервиса.
	EnableDebugStack: true,
}

// Создаем экземпляр приложения
var app = application.New(config)

)
````

<a name="service"></a>
#### 2.2 Service

Сервисом называется сущность имплементирующая интерфейс:

````go
type Service interface {
	Serve() error
	io.Closer
}
````

Для регистрации сервиса необходимо определить его конструктор. Конструктором называется
функция определяющая все зависимости сервиса, но не запускающая его. Сигнатура конструктора
должна соответствовать типу `application.Constructor`. Пример описания конструктора:

````go
package main

...

func runStorageService(ctx context.context, app *application.Application) (application.Service, error) {
	// Инициализируем подключение в базе данных
	db, err := postgres.New()
	if err != nil {
		return nil, err
	}
	
	// Поскольку база данных является ресурсом, то регистрируем его в приложении
	err = app.RegistrationResource(db)
	if err != nil {
		return nil, err
	}
	
	// Инициализируем бизнес-логику
	service, err := storage.New(db)
	if err != nil {
		return nil, err
	}
	
	// Инициализируем API
	srv, err := server.New(service)
	if err != nil {
		return nil, err
	}
	
	return srv, nil
}
````

Функция `Init(config *Config, signals ...os.Signal)` в качестве второго аргумента опционально принимает перечисление системных
вызовов, используя их как сигналы для завершения. Если сигналы не были переданы, то в качестве сигналов будет
использован стандартный набор системных вызовов:

````go
var defaultTerminateSyscall = []os.Signal{
	syscall.SIGHUP,
	syscall.SIGINT,
	syscall.SIGTERM,
	syscall.SIGQUIT,
}
````

Как видно из фрагмента выше: база данных зарегистрирована как ресурс, который будет обработан в функции `Shutdown`. 

>**Немного о graceful shutdown**
>
>_Обычно предполагается, что для безопасного завершения приложения необходимо закрывать соединения в обратном вызову
порядке. Такой подход приводит к образованию сущностей типа `Finalizer`, которые берут на себя эту задачу, однако
при реализации нескольких сервисов внутри одного приложения возникает ситуация, когда один и тот же ресурс используется
несколькими сервисами (например, gRPC-клиент или подключение к базе данных). В таком случае возникают ситуации, 
когда завершение одного сервиса влияет на завершение других, либо функция `main()` превращается в так называемый 
"спагетти код", где тяжело определить зависимости сервисов. Предлагаемый подход позволяет завершить сначала обработку всех входящих
соединений в соответствии с правилами сервисов, а затем безопасно завершить работу всех ресурсов._

Регистрация сервиса осуществляется при помощи метода `RegistrationService`, куда в качестве аргумента передается 
конструктор сервиса или список конструкторов. Пример регистрации конструктора, а также инициализации 
и запуска приложения:

````go
package main

import (
    "github.com/Auvitly/application"
    "log"
    "context"
    ...
)

func main() {

	...

	// Создаем экземпляр приложения
	var app = application.New(config)

	// Регистрируем конструктор StorageService
	err := app.RegistrationService(runStorageService)
	if err != nil {
		log.Fatal(err)
	}
	// Инициализируем приложение
	err = app.Init(ctx)
	if err != nil {
		log.Fatal(err)
    }
	// Запускаем приложение
	err = app.Run(ctx)
	if err != nil {
		log.Fatal(err)
	}

}

func runStorageService(ctx context.context, app *application.Application) (application.Service, error) {
	...
}

````

<a name="state"></a>
#### 2.3 Этапы работы приложения

В рамках пакета установлены следующие состояния приложения:

1. Init - ожидает инициализации
2. Ready - готово к запуску
3. Running - запущено
4. Shutdown - выключается
5. Off - выключено

Состояния устанавливаются для строгого соблюдения последовательности запуска, так если вызывать после функции
`New` сразу же функцию `Run`, то будет получена ошибка, из-за попытки пропуска этапа инициализации или при попытке 
вызвать `Init` во время активной работы приложения.

<a name="graceful"></a>
#### 2.4 Безопасное завершение приложения

Пакет обеспечивает безопасное завершение приложения в случае появления паник с последующим логированием. 
Приложение будет завершено при самостоятельном вызове функции `Shutdown`, контекста переданного в функцию `Run` 
или же системного вызова, указанного в перечне при создании экземпляра `application.Application`.

